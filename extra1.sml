
(*(*Q2*)*)
(**)
(*fun min_max (ys: int list ) =*)
(*  let *)
(*    fun bigger (xs : int list ) = *)
(*      if null xs *)
(*      then 0  *)
(*      else *)
(*        let *)
(*          val  tl_ans = bigger (tl xs)*)
(*        in *)
(*          if  tl_ans > hd xs *)
(*          then tl_ans *)
(*          else hd xs*)
(*        end *)
(**)
(*    fun smaller (zs : int list ) =*)
(*      if null zs *)
(*      then 0 *)
(*      else *)
(*        if null (tl zs) *)
(*        then hd zs *)
(*        else *)
(*          if hd zs < smaller(tl zs) *)
(*          then hd zs*)
(*          else smaller(tl zs)*)
(*  in *)
(*    (bigger(ys), smaller(ys))*)
(*  end*)


(* val lst = [1,2,3,4] *)
(* (*[1,3,6,10]*) *)
(* fun cumsum xs =  *)
(*     let  *)
(*         fun aux (zs , acc, out) =  *)
(*         case zs of  *)
(*              [] => out *)
(*            | e:: [] => e + acc :: out *)
(*            | x::g::xs' => aux (g :: xs' ,x + g + acc ,  acc ::out ) *)
(*     in  *)
(*         hd xs :: aux (xs , 0, []) *)
(*     end  *)
(**)
(* val m = cumsum lst *)

(* val w = SOME "bedo"  *)
(**)
(* fun greeting opt =  *)
(*     case opt of  *)
(*          SOME i => "Hello there , " ^ i  *)
(*        | NONE => "Hello there, you" *)
(**)
(* val x = greeting w *)

(*6*)
(* val a = SOME 1  *)
(* val b = SOME 2  *)
(**)
(* fun addOpt (x,y) =  *)
(*     case (x,y) of  *)
(*          (SOME i , SOME e ) => SOME (i + e)  *)
(*        | _ => NONE  *)
(**)
(* val w = addOpt(a,b) *)

(*7*)
(*not solved*)
(* val g = [SOME 1 , NONE , SOME 2] *)
(**)
(* fun addAllOpt xs =  *)
(*     let *)
(*         fun hel1 (ws, acc) =  *)
(*             case ws of  *)
(*                  [] => NONE *)
(*                | w::ws' => addOpt (w, acc )  *)
(*     in  *)
(*         hel1(xs, SOME 0)  *)
(*     end  *)
(* val z = addAllOpt g *)

(*8*)
(* val a = [true, false ,false] *)
(**)
(* fun any xs =  *)
(*     case xs of  *)
(*          [] => false  *)
(*        | x::xs' => x orelse any xs' *)
(**)
(* val w = any a *)

(*9*)
(* val a = [true, true,false] *)
(**)
(* fun all xs =  *)
(*     case xs of  *)
(*          [] => true *)
(*        | x::xs' => x andalso all xs' *)
(**)
(* val w = all a *)

(*10*) 
(* val a = [1,2,3] *)
(* val b = [4,6,9] *)
(**)
(* fun zip (xs, ys) =  *)
(*     case (xs, ys) of  *)
(*         (_,[]) =>  [] *)
(*        |([],_) =>  [] *)
(*        |(x::xs', y::ys') => [(x,y)] @ zip (xs',ys')  *)
(**)
(* val w = zip (a, b) *)

(*11*)
(*challenge --> leave it for later*)

(*12*)
(*also a challenge*)

(*13*)
(* val a = [("bedo",1), ("ahmed",2) , ("karam", 3)] *)
(* val b = "khalaf" *)
(**)
(* fun lookup (xs , s2) =  *)
(*     case xs of  *)
(*          [] => NONE  *)
(*        | ((s1,i)::xs') => if s1 = s2  *)
(*                           then SOME i  *)
(*                           else lookup(xs',s2) *)
(* val w = lookup(a,b) *)

(*14*)
(* val a = [1,~2,3,~4,5,~6] *)
(* (* ([1,3,5],[~2,~4,~6]) *) *)
(**)
(* fun splitup xs =  *)
(*     let  *)
(*         fun check n =  *)
(*              n > 0 *)
(*         fun pos zs =  *)
(*             case zs of  *)
(*                  [] => []  *)
(*                | z::zs' => if check z  *)
(*                            then z :: pos zs' *)
(*                            else pos zs' *)
(*         fun neg ms =  *)
(*             case ms of  *)
(*                  [] => []  *)
(*                | m::ms' => if  not (check m) *)
(*                            then m :: neg ms' *)
(*                            else neg ms' *)
(*         fun bear (js , ks ) = *)
(*             (js,ks) *)
(*     in  *)
(*         bear (pos xs , neg xs ) *)
(*     end *)
(**)
(* val w = splitup a *)

(*15*)
(* val a = [0,1,2,3,4,5,6,7,8,9,10] *)
(* val b = 5  *)
(**)
(* fun splitAt (xs , n) =  *)
(*     let  *)
(*         fun check i =  *)
(*              i > n  *)
(*         fun pos zs =  *)
(*             case zs of  *)
(*                  [] => []  *)
(*                | z::zs' => if check z  *)
(*                            then z :: pos zs' *)
(*                            else pos zs' *)
(*         fun neg ms =  *)
(*             case ms of  *)
(*                  [] => []  *)
(*                | m::ms' => if  not (check m) andalso m <> n *)
(*                            then m :: neg ms' *)
(*                            else neg ms' *)
(*         fun bear (js , ks ) = *)
(*             (js,ks) *)
(*     in  *)
(*         bear (neg xs , pos xs ) *)
(*     end *)
(**)
(* val w = splitAt(a,b) *)

(*16*)
(* val a = [0,1,2,3,4,5,10,6,7,9,10] *)
(**)
(* fun isSorted xs =  *)
(*     case xs of  *)
(*          [] => false *)
(*        | _::[] => true *)
(*        | x::g::xs' => x <= g andalso isSorted (g::xs') *)
(**)
(* val w = isSorted a *)

(*17*)
val a = [0,1,2,3,4,5,1,7,8,9,10]
val b = [10,9,8,7,6,5,4,3,2,1,0]
val c = [5,3,10,0,2,7,6,8,1,4,9]

fun isAnySorted xs =
    case xs of
         [] => false
       | _ :: [] => true
       | x::g::xs' => x <= g andalso isAnySorted(g::xs')

val w = isAnySorted a
