
(*(*Q2*)*)
(**)
(*fun min_max (ys: int list ) =*)
(*  let *)
(*    fun bigger (xs : int list ) = *)
(*      if null xs *)
(*      then 0  *)
(*      else *)
(*        let *)
(*          val  tl_ans = bigger (tl xs)*)
(*        in *)
(*          if  tl_ans > hd xs *)
(*          then tl_ans *)
(*          else hd xs*)
(*        end *)
(**)
(*    fun smaller (zs : int list ) =*)
(*      if null zs *)
(*      then 0 *)
(*      else *)
(*        if null (tl zs) *)
(*        then hd zs *)
(*        else *)
(*          if hd zs < smaller(tl zs) *)
(*          then hd zs*)
(*          else smaller(tl zs)*)
(*  in *)
(*    (bigger(ys), smaller(ys))*)
(*  end*)


(* val lst = [1,2,3,4] *)
(* (*[1,3,6,10]*) *)
(* fun cumsum xs =  *)
(*     let  *)
(*         fun aux (zs , acc, out) =  *)
(*         case zs of  *)
(*              [] => out *)
(*            | e:: [] => e + acc :: out *)
(*            | x::g::xs' => aux (g :: xs' ,x + g + acc ,  acc ::out ) *)
(*     in  *)
(*         hd xs :: aux (xs , 0, []) *)
(*     end  *)
(**)
(* val m = cumsum lst *)

(* val w = SOME "bedo"  *)
(**)
(* fun greeting opt =  *)
(*     case opt of  *)
(*          SOME i => "Hello there , " ^ i  *)
(*        | NONE => "Hello there, you" *)
(**)
(* val x = greeting w *)

(*6*)
(* val a = SOME 1  *)
(* val b = SOME 2  *)
(**)
(* fun addOpt (x,y) =  *)
(*     case (x,y) of  *)
(*          (SOME i , SOME e ) => SOME (i + e)  *)
(*        | _ => NONE  *)
(**)
(* val w = addOpt(a,b) *)

(*7*)
(*not solved*)
(* val g = [SOME 1 , NONE , SOME 2] *)
(**)
(* fun addAllOpt xs =  *)
(*     let *)
(*         fun hel1 (ws, acc) =  *)
(*             case ws of  *)
(*                  [] => NONE *)
(*                | w::ws' => addOpt (w, acc )  *)
(*     in  *)
(*         hel1(xs, SOME 0)  *)
(*     end  *)
(* val z = addAllOpt g *)

(*8*)
(* val a = [true, false ,false] *)
(**)
(* fun any xs =  *)
(*     case xs of  *)
(*          [] => false  *)
(*        | x::xs' => x orelse any xs' *)
(**)
(* val w = any a *)

(*9*)
(* val a = [true, true,false] *)
(**)
(* fun all xs =  *)
(*     case xs of  *)
(*          [] => true *)
(*        | x::xs' => x andalso all xs' *)
(**)
(* val w = all a *)

(*10*) 
(* val a = [1,2,3] *)
(* val b = [4,6,9] *)
(**)
(* fun zip (xs, ys) =  *)
(*     case (xs, ys) of  *)
(*         (_,[]) =>  [] *)
(*        |([],_) =>  [] *)
(*        |(x::xs', y::ys') => [(x,y)] @ zip (xs',ys')  *)
(**)
(* val w = zip (a, b) *)

(*11*)
(*challenge --> leave it for later*)

(*12*)
(*also a challenge*)

(*13*)
(* val a = [("bedo",1), ("ahmed",2) , ("karam", 3)] *)
(* val b = "khalaf" *)
(**)
(* fun lookup (xs , s2) =  *)
(*     case xs of  *)
(*          [] => NONE  *)
(*        | ((s1,i)::xs') => if s1 = s2  *)
(*                           then SOME i  *)
(*                           else lookup(xs',s2) *)
(* val w = lookup(a,b) *)

(*14*)
(* val a = [1,~2,3,~4,5,~6] *)
(* (* ([1,3,5],[~2,~4,~6]) *) *)
(**)
(* fun splitup xs =  *)
(*     let  *)
(*         fun check n =  *)
(*              n > 0 *)
(*         fun pos zs =  *)
(*             case zs of  *)
(*                  [] => []  *)
(*                | z::zs' => if check z  *)
(*                            then z :: pos zs' *)
(*                            else pos zs' *)
(*         fun neg ms =  *)
(*             case ms of  *)
(*                  [] => []  *)
(*                | m::ms' => if  not (check m) *)
(*                            then m :: neg ms' *)
(*                            else neg ms' *)
(*         fun bear (js , ks ) = *)
(*             (js,ks) *)
(*     in  *)
(*         bear (pos xs , neg xs ) *)
(*     end *)
(**)
(* val w = splitup a *)

(*15*)
(* val a = [0,1,2,3,4,5,6,7,8,9,10] *)
(* val b = 5  *)
(**)
(* fun splitAt (xs , n) =  *)
(*     let  *)
(*         fun check i =  *)
(*              i > n  *)
(*         fun pos zs =  *)
(*             case zs of  *)
(*                  [] => []  *)
(*                | z::zs' => if check z  *)
(*                            then z :: pos zs' *)
(*                            else pos zs' *)
(*         fun neg ms =  *)
(*             case ms of  *)
(*                  [] => []  *)
(*                | m::ms' => if  not (check m) andalso m <> n *)
(*                            then m :: neg ms' *)
(*                            else neg ms' *)
(*         fun bear (js , ks ) = *)
(*             (js,ks) *)
(*     in  *)
(*         bear (neg xs , pos xs ) *)
(*     end *)
(**)
(* val w = splitAt(a,b) *)

(*16*)
(* val a = [0,1,2,3,4,5,6,7,8,9,10] *)
(* val b = [10,9,8,7,6,5,4,3,2,1,0] *)
(* val c = [5,4,9,10,0,7,6,3,8,2] *)
(**)
(* fun isSort xs =  *)
(*     case xs of  *)
(*          [] => false  *)
(*        | _ ::[] => true *)
(*        | x::g::xs' => x <= g andalso isSort(g::xs') *)
(**)
(* val w = isSort a *)

(* val a = [0,1,2,3,4,5,6,7,8,9,10] *)
(* val b = [10,9,8,7,6,5,4,3,2,1,0] *)
(* val c = [5,4,9,10,0,7,6,3,8,2] *)
(**)
(* fun isAnySorted xs =  *)
(*     let  *)
(*         fun increasing ys =  *)
(*             case ys of  *)
(*                  [] => false *)
(*                | _::[] => true *)
(*                | y::e::ys' => y <= e andalso increasing (e::ys') *)
(**)
(*         fun decreasing zs =  *)
(*             case zs of  *)
(*                  [] => false  *)
(*                | _::[] => true  *)
(*                | z::h::zs' => z >= h andalso decreasing (h::zs') *)
(*     in  *)
(*         increasing xs orelse decreasing xs  *)
(*     end *)
(**)
(* val w = isAnySorted c *)

(*18*)
(* val a = [0,1,2,3,4] *)
(* val b = [5,6,7,8,9] *)
(**)
(* fun sortedMerg (xs ,ys) =   *)
(*     if isSort xs andalso isSort ys  *)
(*     then xs @ ys  *)
(*     else [] *)
(**)
(* val w = sortedMerg(a,b) *)

(*19*)
(* val a = [42, 7, 19, 85, 3, 64, 28, 11, 50, 36] *)
(* [3,7,19,28,11,36] [85,64,50] *)
(* [3,7,11,19,36] [50,64,85] *)
(* [3,7,11,19,36,50,64,85] *)
(* [3,7,11,19,36,42,50,64,85]*)(* you need to put 42 back in *)
(*make a function that sorts an int list*)
(*make a function that take a sorted list and a number , and puts that number in
    * it's place*)

(* fun put (n , lst) =  *)
(*     case lst of  *)
(*          [] => n :: lst  *)
(*        | x::xs' => if x > n  *)
(*                    then put (n,xs')  *)
(*                    else n :: xs' *)

(* fun qsort xs =  *)
(*     let  *)
(*         fun splitAt (xs , n) =  *)
(*             let  *)
(*                 fun check i =  *)
(*                      i > n  *)
(*                 fun pos zs =  *)
(*                     case zs of  *)
(*                          [] => []  *)
(*                        | z::zs' => if check z  *)
(*                                    then z :: pos zs' *)
(*                                    else pos zs' *)
(*                 fun neg ms =  *)
(*                     case ms of  *)
(*                          [] => []  *)
(*                        | m::ms' => if  not (check m) andalso m <> n *)
(*                                    then m :: neg ms' *)
(*                                    else neg ms' *)
(*                 fun bear (js , ks ) = *)
(*                     (js,ks) *)
(*             in  *)
(*                 bear (neg xs , pos xs ) *)
(*             end *)
(*         fun sortedMerg (xs ,ys) =   *)
(*             if isSort xs andalso isSort ys  *)
(*             then xs @ ys  *)
(*             else [] *)
(**)
(*     in  *)
(*         case xs of  *)
(*              [] => [] *)
(*            | x::xs' => splitAt (xs, x) *)
(*     end  *)


(*20*)
(* val a = [0,1,2,3,4,5,6,7,8,9,10] *)
(* (*[0,2,4,6,8,10]*) *)
(* (*[1,3,5,7,9]*) *)
(**)
(* fun divide xs =  *)
(*     let *)
(*         fun lst1 l1 =  *)
(*             case l1 of  *)
(*                  [] => []  *)
(*                | lg1:: [] => lg1::[] *)
(*                | l::_::lgs => l :: lst1 lgs *)
(*         fun lst2 l2 =  *)
(*             case l2 of  *)
(*                  [] => []  *)
(*                | _::[] => [] *)
(*                | _::lh::lhs => lh :: lst2 lhs *)
(*     in *)
(*            (lst1 xs , lst2 xs) *)
(*     end *)
(**)
(* val w = divide a *)

(* fun mergeSort xs = *)
(*     let val len = length xs *)
(*         fun insertSort [] = [] *)
(*           | insertSort [x] = [x] *)
(*           | insertSort (x::xs) = *)
(*               let fun insert (x, []) = [x] *)
(*                     | insert (x, y::ys) = *)
(*                         if x <= y then x :: y :: ys *)
(*                         else y :: insert (x, ys) *)
(*               in insert (x, insertSort xs) *)
(*               end *)
(*         fun merge (xs, []) = xs *)
(*           | merge ([], ys) = ys *)
(*           | merge (x::xs, y::ys) = *)
(*               if x <= y then x :: merge (xs, y::ys) *)
(*               else y :: merge (x::xs, ys) *)
(*     in if len <= 20 then insertSort xs  (* threshold for small lists *) *)
(*        else *)
(*            let val half = len div 2 *)
(*                val left = List.take(xs, half) *)
(*                val right = List.drop(xs, half) *)
(*            in merge (mergeSort left, mergeSort right) *)
(*            end *)
(*     end *)
(*21*)
(* val a = [42, 7, 19, 85, 3, 64, 28, 11, 50, 36] *)
(**)
(* fun not_so_quick_sort xs =  *)
(*     let  *)
(*         fun divide ys =  *)
(*             let *)
(*                 fun lst1 l1 =  *)
(*                     case l1 of  *)
(*                          [] => []  *)
(*                        | lg1:: [] => lg1::[] *)
(*                        | l::_::lgs => l :: lst1 lgs *)
(*                 fun lst2 l2 =  *)
(*                     case l2 of  *)
(*                          [] => []  *)
(*                        | _::[] => [] *)
(*                        | _::lh::lhs => lh :: lst2 lhs *)
(*             in *)
(*                    (lst1 ys , lst2 ys) *)
(*             end *)
(*         fun isSort zs =  *)
(*             case zs of  *)
(*                  [] => false  *)
(*                | _ ::[] => true *)
(*                | z::g::zs' => z <= g andalso isSort(g::zs') *)
(*         fun sortedMerg (ws ,vs) =   *)
(*             if isSort ws andalso isSort vs  *)
(*             then ws @ vs  *)
(*             else [] *)
(*     in  *)
(*         case divide xs of  *)
(*              ([],[]) =>  *)
(*            | (c1,c2) => if isSort c1  *)
(*     end  *)
(**)
(* val w = not_so_quick_sort a *)

(*22*)
val a = 5
val b = 9

fun fullDivide (x,y) = 

