
(*5*)
(* val a = [1,2,3]  *)
(* val b = [3,0,1] *)
(* fun repeat (xs, ys) =  *)
(*   let  *)
(*     fun hel1 (x,y) =  *)
(*       if y > 0  *)
(*       then x :: hel1(x,y-1) *)
(*       else [] *)
(*   in *)
(*     case xs of  *)
(*          [] => [] *)
(*        | x::xs' =>  *)
(*            case ys of  *)
(*                 [] => [] *)
(*               | y::ys' => hel1(x,y) @ repeat(xs',ys') *)
(*   end *)
(**)
(* val w = repeat(a,b) *)

(*6*)
(* val a = SOME 1  *)
(* val b = SOME 2  *)
(* fun addOpt (x,y) =  *)
(*   case (x,y) of  *)
(*        (SOME i , SOME e ) => SOME (i + e)  *)
(*      | _ => NONE *)
(**)
(* val w = addOpt(a,b) *)
(**)
(* (*7*) *)
(* val a = [SOME 1 , NONE , SOME 2] *)
(**)
(* fun addAllOpt xs =  *)
(*   case xs of  *)
(*        [] => NONE  *)
(*      | x::xs' =>  *)
(**)
(**)
(* val w = addAllOpt a *)

(* exception IllegalMove *)
(**)
(* val card_list = [1,2,3] *)
(* val held_list = [4,5,6] *)
(**)
(* fun draw (xs, ys, ex) =  *)
(*   case ys of  *)
(*        [] => score (held_cards, my_goal) *)
(*      | y::ys' =>  *)
(*          if isScore(soce(held_cards, my_goal)) *)
(*          then score(held_cards, my_goal) *)
(*          else officete (ys' , xs' ,my_goal ) *)
(*          y :: xs  *)
(**)
(* val w = draw(held_list,card_list, ex) *)

(* fun pow (x, y) =  *)
(*     if y = 0  *)
(*     then 1  *)
(*     else x * pow (x,y-1) *)
(**)
(* val w = pow (2,4) *)
(**)
(* fun swap (pr: int*bool) =  *)
(*     (#2 pr , #1 pr) *)
(**)
(* fun sum_two_pairs (pr1: int*int , pr2: int*int) =  *)
(*     (#1 pr1 + #1 pr2 , #2 pr1, #2 pr2) *)
(**)
(* fun good_max xs =  *)
(*     if null xs  *)
(*     then 0  *)
(*     else  *)
(*         if null (tl xs)  *)
(*         then hd xs  *)
(*         else  *)
(*             let  *)
(*                 val tl_ans = good_max(tl xs)  *)
(*             in  *)
(*                 if hd xs > tl_ans  *)
(*                 then hd xs  *)
(*                 else tl_ans *)
(*             end *)
(**)
(* fun better_max xs =  *)
(*     if null xs  *)
(*     then NONE  *)
(*     else  *)
(*         let  *)
(*             val tl_ans = better_max(tl xs)  *)
(*         in  *)
(*             if isSome tl_ans andalso valOf tl_ans > hd xs  *)
(*             then tl_ans  *)
(*             else SOME (hd xs)  *)
(*         end  *)
(**)
(* val lista = [1,5,9,10] *)
(* val m = better_max(lista) *)
(**)
(* fun sort_pair pr =  *)
(*     if (#1 pr ) < (#2 pr)  *)
(*     then pr  *)
(*     else ((#2 pr, #1 pr)) *)
(**)
(* val x = (3,4)  *)
(* val y = sort_pair(x) *)
(**)
(* fun append (xs, ys) =  *)
(*     if null xs  *)
(*     then ys  *)
(*     else (hd xs) :: append (tl xs , ys) *)

(* fun int_to_list (x1, x2) =  *)
(*     if x1 > x2  *)
(*     then []  *)
(*     else x1 :: int_to_list(x1 + 1 , x2) *)
(**)
(* val m = int_to_list(1,5) *)

(* fun is_older (date1: int*int*int, date2:int*int*int) =  *)
(*     (#1 date1 < #1 date2) orelse  *)
(*     (#1 date1 = #1 date2 andalso ( *)
(*     (#2 date1 < #2 date2) orelse  *)
(*     (#2 date1 = #2 date2 andalso #3 date1 < #3 date2) *)
(*     )) *)
(**)
(* val test1 = is_older ((1,2,3),(2,3,4)) = true *)
(**)
(* fun oldest (dates: (int*int*int) list) =  *)
(* let  *)
(*     fun hel8 (x, l) =  *)
(*         if null l  *)
(*         then true *)
(*         else is_older (x, hd l) andalso hel8 (x, tl l) *)
(* in  *)
(*     if null dates  *)
(*     then NONE  *)
(*     else  *)
(*         if hel8 (hd dates, tl dates) *)
(*         then SOME (hd dates)  *)
(*         else oldest(tl dates) *)
(* end *)
(* val test11 = oldest([(2012,2,28),(2011,3,31),(2011,4,28)]) = SOME (2011,3,31) *)

fun pow (x:int, y:int) = 
    if y = 0 
    then 1 
    else x * pow (x, y-1)

fun cube (x:int) = 
    pow (x,3)

val ans = cube 4
